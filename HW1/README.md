### Домашнее задание 1

В файле restore.py представлена реализация алгоритма AHD.

В качестве деталей можно отметить:
- окрестности для поиска соседей в алгоритме имеют размер 5x5
- такой же размер имеет `median filter` при исправлении артефактов
- фильтр `h` используется в виде `[-0.25, 0.5, 0.5, 0.5, -0.25]`
- в качестве `epsilon` используется максимум из соседних пикселей
перпендикулярно направлению интерполяции, так результат получается лучше
- сглаживание медианой проводится 3 раза, как предлагается в статье
- в качестве low-pass filter используется билинейная интерполяция изображений
- когда в конце получались числа, превыщающие 255, или меньшие 0, они обрезались
до 255 и 0 соответственно.

Итоги:
- Время работы алгоритма на картинке в 26 МБ - порядка 19 секунд, то есть
throughput составляет приблизительно 1.4 МБ/c. Уверен, что на C++ можно было
бы быстрее :) Если в мегапикселях на цветной картинке - это приблизительно 0.4 МП / c.
- PSNR по цветам:
```
PSNR for red: 20.189
PSNR for green: 23.066
PSNR for blue: 20.203
```
не самый замечательный результат, но сравнимо с ожидаемыми значениями для такой картинки
- Оценка разрешения: по деталям изображения трудно оценить, во сколько раз уменьшилось итоговое
разрешение, но по линейке по центру видно, что 16 штрихов (на центральной справа) разрешаются,
а 18 уже нет. Получаем, что если на изначальной отметка 20 еще различалась, то разрешение уменьшилось
вдвое.

#### UPD: опечатка - исправляю уже 25 октября, но здесь, очевидно, разрешение уменьшилось на ~25% (20/16 - 1).

Запуск:

```
python3 restore.py CFA.bmp out.bmp --original_file=Original.bmp
```